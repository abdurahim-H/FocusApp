<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto-Executing Checkbox Layout Test</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/components.css">
    <style>
        body { 
            background: #0f0f23; 
            color: #ccc; 
            font-family: 'Courier New', monospace; 
            padding: 20px; 
            line-height: 1.6;
        }
        .container { 
            border: 2px solid #333; 
            padding: 20px; 
            margin: 20px 0; 
            background: rgba(255,255,255,0.05);
        }
        h1 { color: #4CAF50; }
        .console-output {
            background: #000;
            color: #0f0;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>üîç Auto-Executing Checkbox Layout Test</h1>
    <p>This page will automatically test checkbox behavior and report layout issues.</p>
    
    <div class="container">
        <h3>Test Area</h3>
        <div class="input-group">
            <input type="text" id="taskInput" placeholder="Test task" value="Auto Layout Test">
            <button onclick="window.addTask && window.addTask()">Add Task</button>
        </div>
        <ul id="taskList" class="task-list"></ul>
    </div>

    <div class="console-output" id="console"></div>

    <script type="module">
        import { state } from './js/state.js';
        import { addTask, toggleTask, renderTasks } from './js/tasks.js';
        import { initUIEffects } from './js/ui-effects.js';
        
        // Make functions globally available
        window.addTask = addTask;
        window.toggleTask = toggleTask;
        window.state = state;
        
        const consoleDiv = document.getElementById('console');
        
        // Override console.log to capture output
        const originalLog = console.log;
        const originalWarn = console.warn;
        const originalError = console.error;
        
        function logToDiv(type, ...args) {
            const timestamp = new Date().toLocaleTimeString();
            const message = args.join(' ');
            consoleDiv.textContent += `[${timestamp}] ${type}: ${message}\n`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
            
            // Also log to real console
            if (type === 'LOG') originalLog(...args);
            else if (type === 'WARN') originalWarn(...args);
            else if (type === 'ERROR') originalError(...args);
        }
        
        console.log = (...args) => logToDiv('LOG', ...args);
        console.warn = (...args) => logToDiv('WARN', ...args);
        console.error = (...args) => logToDiv('ERROR', ...args);
        
        // Auto-execute test after initialization
        async function runAutoTest() {
            console.log('üöÄ AUTO-EXECUTING CHECKBOX LAYOUT TEST');
            console.log('='.repeat(50));
            
            try {
                // Initialize
                await initUIEffects();
                renderTasks();
                console.log('‚úÖ UI Effects initialized');
                
                // Clear any existing tasks
                state.tasks = [];
                renderTasks();
                console.log('üóëÔ∏è Cleared existing tasks');
                
                // Add test task
                document.getElementById('taskInput').value = 'Automatic Layout Test Task';
                addTask();
                console.log('‚ûï Added test task');
                
                if (state.tasks.length === 0) {
                    console.error('‚ùå CRITICAL: Failed to add task!');
                    return;
                }
                
                console.log(`üìä Task added successfully. ID: ${state.tasks[0].id}`);
                
                // Wait for rendering
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Get container measurements BEFORE toggle
                const container = document.querySelector('.container');
                const taskList = document.getElementById('taskList');
                
                const beforeContainer = container.getBoundingClientRect();
                const beforeTaskList = taskList.getBoundingClientRect();
                const beforeClasses = container.className;
                
                console.log('üìè MEASUREMENTS BEFORE CHECKBOX TOGGLE:');
                console.log(`  Container: ${beforeContainer.width.toFixed(1)}√ó${beforeContainer.height.toFixed(1)} at (${beforeContainer.top.toFixed(1)}, ${beforeContainer.left.toFixed(1)})`);
                console.log(`  Task List: ${beforeTaskList.width.toFixed(1)}√ó${beforeTaskList.height.toFixed(1)} at (${beforeTaskList.top.toFixed(1)}, ${beforeTaskList.left.toFixed(1)})`);
                console.log(`  Container Classes: "${beforeClasses}"`);
                console.log(`  Task List Children: ${taskList.children.length}`);
                
                // Set up observers for changes
                let classChanges = [];
                let domChanges = [];
                
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                            classChanges.push({
                                element: mutation.target.tagName + (mutation.target.id ? '#' + mutation.target.id : ''),
                                oldValue: mutation.oldValue || '',
                                newValue: mutation.target.className || ''
                            });
                        }
                        if (mutation.type === 'childList') {
                            domChanges.push({
                                target: mutation.target.tagName + (mutation.target.id ? '#' + mutation.target.id : ''),
                                added: mutation.addedNodes.length,
                                removed: mutation.removedNodes.length
                            });
                        }
                    });
                });
                
                observer.observe(document.body, {
                    attributes: true,
                    attributeOldValue: true,
                    subtree: true,
                    childList: true,
                    attributeFilter: ['class', 'style']
                });
                
                // EXECUTE THE CHECKBOX TOGGLE
                console.log('‚òëÔ∏è EXECUTING CHECKBOX TOGGLE...');
                const taskId = state.tasks[0].id;
                toggleTask(taskId);
                
                // Check immediate effects (50ms)
                await new Promise(resolve => setTimeout(resolve, 50));
                
                const after50ms = {
                    container: container.getBoundingClientRect(),
                    taskList: taskList.getBoundingClientRect(),
                    classes: container.className
                };
                
                console.log('üìè MEASUREMENTS 50ms AFTER TOGGLE:');
                console.log(`  Container: ${after50ms.container.width.toFixed(1)}√ó${after50ms.container.height.toFixed(1)} at (${after50ms.container.top.toFixed(1)}, ${after50ms.container.left.toFixed(1)})`);
                console.log(`  Task List: ${after50ms.taskList.width.toFixed(1)}√ó${after50ms.taskList.height.toFixed(1)} at (${after50ms.taskList.top.toFixed(1)}, ${after50ms.taskList.left.toFixed(1)})`);
                console.log(`  Container Classes: "${after50ms.classes}"`);
                
                // Calculate changes
                const containerWidthChange = Math.abs(beforeContainer.width - after50ms.container.width);
                const containerHeightChange = Math.abs(beforeContainer.height - after50ms.container.height);
                const containerTopChange = Math.abs(beforeContainer.top - after50ms.container.top);
                const containerLeftChange = Math.abs(beforeContainer.left - after50ms.container.left);
                
                console.log('üìä IMMEDIATE LAYOUT CHANGES (50ms):');
                console.log(`  Container Width Change: ${containerWidthChange.toFixed(2)}px`);
                console.log(`  Container Height Change: ${containerHeightChange.toFixed(2)}px`);
                console.log(`  Container Top Change: ${containerTopChange.toFixed(2)}px`);
                console.log(`  Container Left Change: ${containerLeftChange.toFixed(2)}px`);
                console.log(`  Classes Changed: ${beforeClasses !== after50ms.classes}`);
                
                // Report immediate issues
                if (containerWidthChange > 1) console.warn(`üö® ISSUE: Container width changed by ${containerWidthChange.toFixed(2)}px`);
                if (containerHeightChange > 1) console.warn(`üö® ISSUE: Container height changed by ${containerHeightChange.toFixed(2)}px`);
                if (containerTopChange > 1) console.warn(`üö® ISSUE: Container shifted vertically by ${containerTopChange.toFixed(2)}px`);
                if (containerLeftChange > 1) console.warn(`üö® ISSUE: Container shifted horizontally by ${containerLeftChange.toFixed(2)}px`);
                if (beforeClasses !== after50ms.classes) {
                    console.warn(`üö® ISSUE: Container classes changed from "${beforeClasses}" to "${after50ms.classes}"`);
                }
                
                // Monitor changes over time
                console.log('‚è∞ MONITORING FOR ONGOING CHANGES...');
                
                for (let i = 1; i <= 20; i++) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    const current = {
                        container: container.getBoundingClientRect(),
                        classes: container.className
                    };
                    
                    const currentWidthChange = Math.abs(beforeContainer.width - current.container.width);
                    const currentHeightChange = Math.abs(beforeContainer.height - current.container.height);
                    const currentTopChange = Math.abs(beforeContainer.top - current.container.top);
                    const currentLeftChange = Math.abs(beforeContainer.left - current.container.left);
                    
                    if (currentWidthChange > 1 || currentHeightChange > 1 || currentTopChange > 1 || currentLeftChange > 1 || beforeClasses !== current.classes) {
                        console.warn(`üîÑ LAYOUT CHANGE at ${i * 100}ms: Size: ${current.container.width.toFixed(1)}√ó${current.container.height.toFixed(1)}, Classes: "${current.classes}"`);
                    }
                }
                
                observer.disconnect();
                
                console.log('üìù DETECTED CLASS CHANGES:');
                classChanges.forEach(change => {
                    console.log(`  ${change.element}: "${change.oldValue}" ‚Üí "${change.newValue}"`);
                });
                
                console.log('üìù DETECTED DOM CHANGES:');
                domChanges.forEach(change => {
                    console.log(`  ${change.target}: +${change.added} -${change.removed} nodes`);
                });
                
                console.log('üèÅ CHECKBOX LAYOUT TEST COMPLETED');
                console.log('='.repeat(50));
                
            } catch (error) {
                console.error('‚ùå TEST FAILED:', error);
            }
        }
        
        // Start test after page loads
        window.addEventListener('load', () => {
            setTimeout(runAutoTest, 500);
        });
    </script>
</body>
</html>
