<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Focus - Debug Mode</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #scene-container canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 400px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.4;
        }
        .nav {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }
        .nav-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 10px 20px;
            margin: 0 5px;
            cursor: pointer;
            border-radius: 5px;
        }
        .nav-btn:hover {
            background: rgba(255,255,255,0.2);
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    
    <div id="debug-info">
        <h3>Cosmic Focus - Debug Mode</h3>
        <div id="status">Initializing...</div>
        <div id="logs"></div>
    </div>

    <nav class="nav">
        <button class="nav-btn" onclick="location.reload()">Reload</button>
        <button class="nav-btn" onclick="clearLogs()">Clear Logs</button>
    </nav>

    <!-- Babylon.js Scripts -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>
        let logCount = 0;
        
        function log(message, type = 'info') {
            logCount++;
            console.log(`[${logCount}] ${message}`);
            const logs = document.getElementById('logs');
            const color = type === 'error' ? '#ff6b6b' : type === 'success' ? '#51cf66' : '#74c0fc';
            logs.innerHTML += `<div style="color: ${color}">[${logCount}] ${message}</div>`;
            logs.scrollTop = logs.scrollHeight;
        }

        function setStatus(message) {
            document.getElementById('status').innerHTML = `<strong>${message}</strong>`;
            log(`Status: ${message}`);
        }

        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
            logCount = 0;
        }

        // Initialize the scene
        let engine, scene, camera;
        let stars = [];
        let planets = [];
        let blackHoleSystem = {};

        function initBabylonScene() {
            try {
                setStatus('Checking Babylon.js...');
                if (typeof BABYLON === 'undefined') {
                    throw new Error('Babylon.js not loaded');
                }
                log('Babylon.js loaded successfully', 'success');

                setStatus('Creating scene container...');
                const container = document.getElementById('scene-container');
                if (!container) {
                    throw new Error('Scene container not found');
                }
                log('Scene container found', 'success');

                setStatus('Creating canvas...');
                const canvas = document.createElement('canvas');
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.display = 'block';
                container.appendChild(canvas);
                log('Canvas created and added to container', 'success');

                setStatus('Creating Babylon.js engine...');
                engine = new BABYLON.Engine(canvas, true, {
                    preserveDrawingBuffer: true,
                    stencil: true,
                    antialias: true,
                    alpha: true
                });
                log('Babylon.js engine created successfully', 'success');

                setStatus('Creating scene...');
                scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color3(0, 0, 0.1);
                log('Scene created with dark blue background', 'success');

                setStatus('Creating camera...');
                camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(30, 15, 30), scene);
                camera.setTarget(BABYLON.Vector3.Zero());
                camera.fov = 75 * Math.PI / 180;
                camera.minZ = 0.1;
                camera.maxZ = 2000;
                log('Camera created and positioned', 'success');

                setStatus('Creating lighting...');
                const ambientLight = new BABYLON.HemisphericLight("ambientLight", new BABYLON.Vector3(0, 1, 0), scene);
                ambientLight.intensity = 0.5;
                ambientLight.diffuse = new BABYLON.Color3(0.4, 0.4, 0.6);
                log('Ambient lighting created', 'success');

                setStatus('Creating test objects...');
                createTestObjects();

                setStatus('Creating galaxy elements...');
                createGalaxyElements();

                setStatus('Starting render loop...');
                startRenderLoop();

                setStatus('SUCCESS: 3D scene initialized!');
                log('3D scene should now be visible with stars, planets, and cosmic objects', 'success');

            } catch (error) {
                setStatus(`ERROR: ${error.message}`);
                log(`Error details: ${error.toString()}`, 'error');
                console.error('Scene initialization error:', error);
            }
        }

        function createTestObjects() {
            // Create a test sphere to ensure basic rendering works
            const testSphere = BABYLON.MeshBuilder.CreateSphere("testSphere", {diameter: 3}, scene);
            testSphere.position = new BABYLON.Vector3(5, 0, 5);
            
            const testMaterial = new BABYLON.StandardMaterial("testMat", scene);
            testMaterial.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
            testMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.1, 0);
            testSphere.material = testMaterial;
            
            log('Test sphere created at (5,0,5)', 'success');
        }

        function createGalaxyElements() {
            // Create simplified star field
            createStarField();
            
            // Create simple black hole
            createBlackHole();
            
            // Create planets
            createPlanets();
            
            log('Galaxy elements created', 'success');
        }

        function createStarField() {
            const starCount = 5000;
            const starSystem = new BABYLON.ParticleSystem("stars", starCount, scene);
            
            // Create simple white dot texture
            starSystem.particleTexture = new BABYLON.Texture("data:image/svg+xml;base64," + btoa(`
                <svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 8 8">
                    <circle cx="4" cy="4" r="4" fill="white" />
                </svg>
            `), scene);
            
            const emitter = BABYLON.MeshBuilder.CreateBox("starEmitter", {size: 0.01}, scene);
            emitter.isVisible = false;
            starSystem.emitter = emitter;
            starSystem.createSphereEmitter(500);
            
            starSystem.color1 = new BABYLON.Color4(1, 1, 1, 0.8);
            starSystem.color2 = new BABYLON.Color4(0.8, 0.9, 1, 0.6);
            starSystem.minSize = 0.5;
            starSystem.maxSize = 3;
            starSystem.minLifeTime = Number.MAX_VALUE;
            starSystem.maxLifeTime = Number.MAX_VALUE;
            starSystem.emitRate = 0;
            
            starSystem.start();
            
            // Position stars manually
            setTimeout(() => {
                const particles = starSystem.particles;
                for (let i = 0; i < Math.min(starCount, particles.length); i++) {
                    const particle = particles[i];
                    if (particle) {
                        const radius = 300 + Math.random() * 700;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        
                        particle.position = new BABYLON.Vector3(
                            radius * Math.sin(phi) * Math.cos(theta),
                            radius * Math.sin(phi) * Math.sin(theta),
                            radius * Math.cos(phi)
                        );
                        
                        particle.size = 0.5 + Math.random() * 2.5;
                        particle.color = new BABYLON.Color4(
                            0.8 + Math.random() * 0.2,
                            0.8 + Math.random() * 0.2,
                            1,
                            0.7 + Math.random() * 0.3
                        );
                    }
                }
            }, 100);
            
            stars.push(starSystem);
            log('Star field created with 5000 stars', 'success');
        }

        function createBlackHole() {
            const blackHoleGroup = new BABYLON.TransformNode("blackHoleGroup", scene);
            
            // Event horizon
            const eventHorizon = BABYLON.MeshBuilder.CreateSphere("blackHole", {diameter: 6}, scene);
            eventHorizon.parent = blackHoleGroup;
            
            const bhMaterial = new BABYLON.StandardMaterial("blackHoleMat", scene);
            bhMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            bhMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0.2);
            eventHorizon.material = bhMaterial;
            
            // Accretion disk
            const disk = BABYLON.MeshBuilder.CreateTorus("accretionDisk", {
                diameter: 16,
                thickness: 2,
                tessellation: 64
            }, scene);
            disk.parent = blackHoleGroup;
            disk.rotation.x = Math.PI / 2;
            
            const diskMaterial = new BABYLON.StandardMaterial("diskMat", scene);
            diskMaterial.diffuseColor = new BABYLON.Color3(1, 0.5, 0);
            diskMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.2, 0);
            disk.material = diskMaterial;
            
            blackHoleSystem = { group: blackHoleGroup, eventHorizon, disk };
            log('Black hole system created', 'success');
        }

        function createPlanets() {
            const planetConfigs = [
                { size: 2, color: [1, 0.4, 0.4], distance: 25, speed: 0.02 },
                { size: 3, color: [0.3, 0.8, 0.8], distance: 35, speed: 0.015 },
                { size: 1.5, color: [1, 0.9, 0.4], distance: 45, speed: 0.01 }
            ];

            planetConfigs.forEach((config, index) => {
                const planet = BABYLON.MeshBuilder.CreateSphere(`planet${index}`, {diameter: config.size * 2}, scene);
                
                const angle = (Math.PI * 2 * index) / planetConfigs.length;
                planet.position.x = Math.cos(angle) * config.distance;
                planet.position.z = Math.sin(angle) * config.distance;
                
                const material = new BABYLON.StandardMaterial(`planetMat${index}`, scene);
                material.diffuseColor = new BABYLON.Color3(...config.color);
                material.emissiveColor = new BABYLON.Color3(
                    config.color[0] * 0.2,
                    config.color[1] * 0.2,
                    config.color[2] * 0.2
                );
                planet.material = material;
                
                planet.userData = {
                    distance: config.distance,
                    speed: config.speed,
                    angle: angle
                };
                
                planets.push(planet);
            });
            
            log(`Created ${planetConfigs.length} planets`, 'success');
        }

        function startRenderLoop() {
            let time = 0;
            
            // Animation loop
            scene.registerBeforeRender(() => {
                time += 0.016;
                
                // Animate camera orbit
                const cameraRadius = 50;
                const cameraHeight = 20 + Math.sin(time * 0.1) * 5;
                const cameraAngle = time * 0.001;
                
                camera.position.x = Math.sin(cameraAngle) * cameraRadius;
                camera.position.y = cameraHeight;
                camera.position.z = Math.cos(cameraAngle) * cameraRadius;
                camera.setTarget(BABYLON.Vector3.Zero());
                
                // Animate planets
                planets.forEach(planet => {
                    if (planet.userData) {
                        planet.userData.angle += planet.userData.speed;
                        planet.position.x = Math.cos(planet.userData.angle) * planet.userData.distance;
                        planet.position.z = Math.sin(planet.userData.angle) * planet.userData.distance;
                        planet.rotation.y += 0.01;
                    }
                });
                
                // Animate black hole disk
                if (blackHoleSystem.disk) {
                    blackHoleSystem.disk.rotation.y += 0.005;
                }
            });
            
            // Start the render loop
            engine.runRenderLoop(() => {
                scene.render();
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                engine.resize();
            });
            
            log('Render loop started with animations', 'success');
        }

        // Initialize when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initBabylonScene);
        } else {
            initBabylonScene();
        }

        // Error handling
        window.addEventListener('error', (event) => {
            log(`Global error: ${event.error}`, 'error');
        });

        window.addEventListener('unhandledrejection', (event) => {
            log(`Unhandled promise rejection: ${event.reason}`, 'error');
        });
    </script>
</body>
</html>
